# 内存管理简述

## 关于内存

与 CPU 进行沟通的桥梁，计算机中所有的程序都是在内存中进行的。

* 内存储器
* 主存储器

## 内存分区（地址从高到低）

app 启动后，代码区、常量区、全局区大小就已经固定。

* 栈区（Stack）
  * 编译器自动分配释放，存放函数的参数，局部变量的值等
  * 栈是**向低地址扩展**的数据结构，**连续**的内存区域
* 堆区（Heap）
  * **程序员分配释放**
  * 是**向高地址扩展**的数据结构，**不连续**的内存区域
* 全局区
  * 未初始化的全局区/静态区
  * 初始化的全局区/静态区
  * 程序结束后由系统释放
* 常量区
  * 常量字符串就是放在这里的
  * 程序结束后由系统释放
* 代码区
  * 存放函数体的二进制代码

## 内存管理方式

* Tagged Pointer
* NONPOINTER_ISA
* 引用计数

### Tagged Pointer

指针类型的大小通常也是与 CPU 位数相关，在 **32 位** CPU 下为 **4 个字节**，在 **64 位** CPU 下 **8 个字节**。

<br/>

**Tagged Pointer**将一个对象的指针拆分成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。

### NONPOINTER_ISA

isa是一个**联合体**，存储了与该对象相关的一些内存的信息。使用了Tagged Pointer思想，并不需要所有二进制位全部存储指针。

<br/>

少量的引用计数会先存放在 **extra_rc** 中，当其被存满时，才会存入相应的 **SideTables**。

#### SideTables

引用计数被包含在一个 **SideTable** 中， **SideTable** 又包含在一个全局的 **StripeMap** 哈希映射表中，表名 **SideTables**。

<br/>

**SideTable** 主要包含3个成员：

* spinlock_t：自旋锁
* RefcountMap：引用计数
* weak_table_t：弱引用

### 引用计数

对象被强引用的计数。

* 自己生成的对象，自己所持有
* 非自己生成的对象，自己也能持有
* 不再需要自己持有的对象时释放
* 非自己持有的对象无法释放